GoF（Gang of Four）とは、1994年に発表されたデザインパターンの解説書「Design Patterns: Elements of Reusable Object-Oriented Software」を執筆した4人の著者を指します。この本では、オブジェクト指向設計における23の基本的なデザインパターンを紹介しています。著者の4人、Erich Gamma、Richard Helm、Ralph Johnson、John Vlissidesの頭文字から「Gang of Four」、略して「GoF」と呼ばれています。

### GoFデザインパターンとは？
GoFのデザインパターンは、ソフトウェア開発において頻出する問題に対する再利用可能な解決策を提供します。これらのパターンは、設計の柔軟性や再利用性、可読性を向上させるために利用されます。Javaのようなオブジェクト指向言語で非常に役立つもので、コードのメンテナンスや拡張が容易になるため、開発者に広く使用されています。

### GoFデザインパターンの分類
GoFは、23のデザインパターンを以下の3つのカテゴリーに分類しています。

1. **生成に関するパターン（Creational Patterns）**
   - オブジェクトの生成に関わるパターンで、柔軟で効率的なオブジェクト生成の方法を提供します。

2. **構造に関するパターン（Structural Patterns）**
   - オブジェクトの構造やクラスの関係を整理し、柔軟なアーキテクチャを作るためのパターンです。

3. **振る舞いに関するパターン（Behavioral Patterns）**
   - オブジェクト間のやり取りやコミュニケーションを管理するためのパターンです。オブジェクトの振る舞いに関するものが多いです。

---

### 1. 生成に関するパターン（Creational Patterns）
これらのパターンは、オブジェクトの生成を柔軟に行うために使われます。直接インスタンス化するのではなく、生成ロジックを隠蔽し、柔軟で効率的なオブジェクト生成を提供します。

- **Singleton（シングルトン）**
  - 特定のクラスのインスタンスが1つしか存在しないことを保証します。代表例として、アプリケーション全体で1つの設定管理クラスなどが挙げられます。
  
    ```java
    public class Singleton {
        private static Singleton instance;
        private Singleton() {}  // コンストラクタをプライベートに
        public static Singleton getInstance() {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
    ```

- **Factory Method（ファクトリーメソッド）**
  - インスタンスを生成するためのメソッドを提供しますが、具体的なクラスの生成をサブクラスに委ねることができます。これは、クラスがどのオブジェクトを生成するかを知る必要がない場合に便利です。

- **Abstract Factory（抽象ファクトリー）**
  - 互換性のあるオブジェクトのファミリを作成するためのインタフェースを定義します。複数のオブジェクトを同時に生成し、オブジェクト間の関連性を保ちます。

- **Builder（ビルダー）**
  - 複雑なオブジェクトの生成を、段階的に行えるようにします。オブジェクトを部分ごとに組み立てるのに便利です。

- **Prototype（プロトタイプ）**
  - 既存のオブジェクトをコピー（クローン）して新しいインスタンスを生成します。大規模なオブジェクトの複製に有効です。

---

### 2. 構造に関するパターン（Structural Patterns）
構造に関するパターンは、オブジェクトやクラスの構造（関係性）を整理し、システムの柔軟性や効率性を高めます。

- **Adapter（アダプター）**
  - インタフェースの互換性がない2つのクラスを接続するためのパターンです。既存のクラスを変更せずに、新しいインタフェースを追加します。
  
    ```java
    public interface Target {
        void request();
    }
    
    public class Adaptee {
        public void specificRequest() {
            // 特定の動作
        }
    }
    
    public class Adapter implements Target {
        private Adaptee adaptee;
        public Adapter(Adaptee adaptee) {
            this.adaptee = adaptee;
        }
        public void request() {
            adaptee.specificRequest(); // アダプターが違うインターフェースを呼び出し
        }
    }
    ```

- **Bridge（ブリッジ）**
  - 抽象部分とその実装部分を分離し、両者を独立して拡張できるようにします。

- **Composite（コンポジット）**
  - オブジェクトをツリー構造で表現し、個々のオブジェクトと複合オブジェクトを同一視して扱うことができるようにします。

- **Decorator（デコレーター）**
  - 既存のオブジェクトに対して動的に機能を追加します。オブジェクトをラップすることで、機能の追加や変更を行います。

- **Facade（ファサード）**
  - 複雑なシステムに対して、簡単なインターフェースを提供し、システムとのやり取りを容易にします。

- **Flyweight（フライウェイト）**
  - 同じオブジェクトが大量に存在する場合に、共有できる部分を共通化し、メモリの節約を行います。

- **Proxy（プロキシ）**
  - 実際のオブジェクトへのアクセスを制御するために、代理を提供します。アクセス制御、ロギング、キャッシングなどに使われます。

---

### 3. 振る舞いに関するパターン（Behavioral Patterns）
振る舞いに関するパターンは、オブジェクト間のコミュニケーションやアルゴリズムのカプセル化を扱います。

- **Chain of Responsibility（責任の連鎖）**
  - リクエストを処理するオブジェクトのチェーンを作り、処理可能なオブジェクトがそれを処理します。

- **Command（コマンド）**
  - 操作をオブジェクトとしてカプセル化し、実行者と操作対象の分離を行います。

- **Interpreter（インタープリター）**
  - 言語の文法やルールを表現し、それに基づいて文を解釈するパターンです。

- **Iterator（イテレーター）**
  - 集合体（コレクション）内部の要素に順番にアクセスするためのインタフェースを提供します。

- **Mediator（メディエーター）**
  - 複数のオブジェクト間の通信を仲介し、オブジェクト同士の依存関係を減らします。

- **Memento（メメント）**
  - オブジェクトの状態を保存し、後でその状態に戻すためのパターンです。

- **Observer（オブザーバー）**
  - オブジェクトの状態変化を、他のオブジェクトに通知する仕組みを提供します。イベントベースのシステムに多く使われます。

- **State（ステート）**
  - オブジェクトの状態をカプセル化し、状態ごとに異なる振る舞いを提供します。

- **Strategy（ストラテジー）**
  - アルゴリズムや処理の詳細をカプセル化し、動的に切り替えられるようにします。

- **Template Method（テンプレートメソッド）**
  - 処理の流れをテンプレートとして定義し、具体的な処理内容をサブクラスに委ねるパターンです。

- **Visitor（ビジター）**
  - オブジェクトの構造に関係なく、操作を分離して追加できるようにします。

---

### まとめ
GoFのデザインパターンは、オブジェクト指向プログラミングの課題に対する共通の解決策を提供します。これらのパターンを理解し、適切に使用することで、
